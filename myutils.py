from tensorflow.keras.datasets import imdb
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import LSTM
from tensorflow.keras.layers import Conv1D
from tensorflow.keras.layers import MaxPooling1D
from tensorflow.keras.models import load_model
from tensorflow.keras.layers import Embedding
from tensorflow.keras.layers import Bidirectional
from keras.preprocessing import sequence
from keras import backend as K
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.utils import class_weight
import tensorflow as tf
import builtins
import keyword
import pickle
import numpy
import os
from gensim.models import Word2Vec, KeyedVectors
import tensorflow as tf
from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont
from IPython.display import display
from termcolor import colored




def findComments(source_code):
    """
    This function finds the start and end positions of comments in the given source code.

    Parameters:
    source_code (str): The source code to search for comments.

    Returns:
    comment_areas (list): A list of tuples where each tuple represents the start and end position of a comment.
    """
    comment_areas = []
    is_in_comment = False
    comment_start = -1
    comment_end = -1

    for position, char in enumerate(source_code):
        if char == "#":
            if not is_in_comment:
                comment_start = position
                is_in_comment = True

        if char == "\n":
            if is_in_comment:
                comment_end = position
                is_in_comment = False

        if comment_start >= 0 and comment_end >= 0:
            comment_areas.append((comment_start, comment_end))
            comment_start = -1
            comment_end = -1

    return comment_areas


def findposition(bad_part, source_code):
    split_chars = ["\t", "\n", " ", ".", ":", "(", ")", "[", "]", "<", ">", "+", "-", "=","\"", "\'","*", "/","\\","~","{","}","!","?","*",";",",","%","&"]
    pos, match_index, start_found, end_found = 0, 0, -1, -1
    in_a_comment = False
    end = False
    last = 0
    bad_part = bad_part.split("#")[0].lstrip()
    if not bad_part:
        return [-1, -1]
    while not end:
        if pos >= len(source_code):
            end = True
            break
        if source_code[pos] == "\n":
            in_a_comment = False
        if source_code[pos] in ["\n", " "] and source_code[last] in ["\n", " "]:
            pos += 1
            continue
        if source_code[pos] == "#":
            in_a_comment = True
        if not in_a_comment:
            a = source_code[pos] if source_code[pos] != "\n" else " "
            b = bad_part[match_index]
            c = bad_part[match_index - 1] if match_index > 0 else ""
            d = bad_part[match_index + 1] if match_index < len(bad_part) - 2 else ""
            if (a != b) and (a in [" ", "\n"]) and (b in split_chars or c in split_chars):
                pos += 1
                continue
            if (a != b) and (b in [" ", "\n"]) and (c in split_chars or d in split_chars):
                match_index += 1
                continue
            if a == b:
                if match_index == 0:
                    start_found = pos
                match_index += 1
            else:
                match_index = 0
                start_found = -1
            if match_index == len(bad_part):
                end_found = pos
                break
        pos += 1
    if end_found < 0:
        start_found = -1
    return [start_found, end_found] if end_found >= 0 and start_found >= 0 else [-1, -1]


def findpositions(bad_parts, source_code):
    positions = []
    for bad in bad_parts:
        bad = bad.split("#")[0]
        place = findposition(bad, source_code)
        if place != [-1, -1]:
            positions.append(place)
    return positions




def nextsplit(source_code, focus):
    split_chars = [" ", "\t", "\n", ".", ":", "(", ")", "[", "]", "<", ">", "+", "-", "=", "\"", "\'", "*", "/", "\\", "~", "{", "}", "!", "?", "*", ";", ",", "%", "&"]
    for pos in range(focus + 1, len(source_code)):
        if source_code[pos] in split_chars:
            return pos
    return -1

def previoussplit(source_code, focus):
    split_chars = [" ", "\t", "\n", ".", ":", "(", ")", "[", "]", "<", ">", "+", "-", "=", "\"", "\'", "*", "/", "\\", "~", "{", "}", "!", "?", "*", ";", ",", "%", "&"]
    pos = focus - 1
    while pos >= 0:
        if source_code[pos] in split_chars:
            return pos
        pos -= 1
    return -1

def getcontextPos(source_code, focus, full_length):
    start_context = end_context = focus
    if focus > len(source_code) - 1:
        return None

    start = True
    while len(source_code[start_context:end_context]) <= full_length:
        if previoussplit(source_code, start_context) == -1 and nextsplit(source_code, end_context) == -1:
            return None

        if start and previoussplit(source_code, start_context) > -1:
            start_context = previoussplit(source_code, start_context)
            start = False
        elif not start and nextsplit(source_code, end_context) > -1:
            end_context = nextsplit(source_code, end_context)
            start = True

    return [start_context, end_context]

def getcontext(source_code, focus, full_length):
    context_pos = getcontextPos(source_code, focus, full_length)
    return None if context_pos is None else source_code[context_pos[0]:context_pos[1]]



def getblocks(source_code, bad_positions, step, full_length):
    blocks = []
    focus = last_focus = 0

    while focus <= len(source_code):
        focus_area = source_code[last_focus:focus]

        if focus_area != "\n":
            middle = last_focus + round(0.5 * (focus - last_focus))
            context = getcontextPos(source_code, middle, full_length)

            if context is not None:
                vulnerable_pos = any(context[0] > bad[0] <= context[1] or context[1] > bad[0] <= context[1] or context[0] <= bad[0] >= context[1] for bad in bad_positions)
                q = 0 if vulnerable_pos else 1

                single_block = [source_code[context[0]:context[1]], q]
                if single_block[0] not in [b[0] for b in blocks]:
                    blocks.append(single_block)

        if "\n" in source_code[focus + 1:focus + 7]:
            last_focus = focus
            focus += source_code[focus + 1:focus + 7].find("\n") + 1
        else:
            next_split = nextsplit(source_code, focus + step)
            if next_split > -1:
                last_focus = focus
                focus = next_split
            else:
                if focus < len(source_code):
                    last_focus = focus
                    focus = len(source_code)
                else:
                    break

    return blocks


def getBadpart(change):
    lines = change.split("\n")
    removal = any(line[0] == "-" for line in lines if line)

    if not removal:
        return None

    bad_examples = [line[1:] for line in lines if line.lstrip() and line[0] == "-" and "#" not in line[1:].lstrip()[:3] and "import os" not in line]
    good_examples = [line[1:] for line in lines if line.lstrip() and line[0] == "+" and "#" not in line[1:].lstrip()[:3] and "import os" not in line]

    return [bad_examples, good_examples] if bad_examples else None


def getTokens(change):
    change = change.replace(" .", ".").replace(" ,", ",").replace(" )", ")").replace(" (", "(").replace(" ]", "]").replace(" [", "[").replace(" {", "{").replace(" }", "}").replace(" :", ":").replace("- ", "-").replace("+ ", "+").replace(" =", "=").replace("= ", "=")
    split_chars = [" ", "\t", "\n", ".", ":", "(", ")", "[", "]", "<", ">", "+", "-", "=", "\"", "\'", "*", "/", "\\", "~", "{", "}", "!", "?", "*", ";", ",", "%", "&"]
    start = end = 0
    tokens = []

    for i in range(len(change)):
        if change[i] in split_chars:
            if i > start:
                start += 1
                end = i
                token = change[start:end] if start != 1 else change[:end]
                if token:
                    tokens.append(token)
                tokens.append(change[i])
                start = i

    return tokens


def removeDoubleSeperatorsString(string):
    return "".join(removeDoubleSeperators(getTokens(string)))


def removeDoubleSeperators(token_list):
    last = ""
    new_tokens = []

    for token in token_list:
        token = " " if token == "\n" else token
        if token and last != " " or token != " ":
            new_tokens.append(token)
        last = token

    return new_tokens


def isEmpty(code):
    return all(t in ["\n", " "] for t in getTokens(stripComments(code)))


def is_builtin(name):
    return name in builtins.__dict__


def is_keyword(name):
    return name in keyword.kwlist


def removeTripleN(token_list):
    second_last = last = ""
    new_tokens = []

    for token in token_list:
        if token and not (second_last == last == token == "\n"):
            new_tokens.append(token)
        third_last, second_last, last = second_last, last, token

    return new_tokens




def getgoodblocks(source_code, good_positions, full_length):
    blocks = []
    if good_positions:
        for g in good_positions:
            if g:
                focus = g[0]
                while focus < g[1]:
                    context = getcontext(source_code, focus, full_length)
                    if context is not None:
                        single_block = [context, 1]
                        if single_block[0] not in [b[0] for b in blocks]:
                            blocks.append(single_block)
                        next_split = nextsplit(source_code, focus + 15)
                        if next_split > -1:
                            focus = next_split
                        else:
                            break
    return blocks


def stripComments(code):
    lines = code.split("\n")
    without_comments = ""
    for c in lines:
        if "#" in c:
            position = c.find("#")
            c = c[:position]
        without_comments += c + "\n"
    return without_comments





#Define F1 loss and measurement

def f1_loss(y_true, y_pred):

    tp = K.sum(K.cast(y_true*y_pred, 'float'), axis=0)
    tn = K.sum(K.cast((1-y_true)*(1-y_pred), 'float'), axis=0)
    fp = K.sum(K.cast((1-y_true)*y_pred, 'float'), axis=0)
    fn = K.sum(K.cast(y_true*(1-y_pred), 'float'), axis=0)

    p = tp / (tp + fp + K.epsilon())
    r = tp / (tp + fn + K.epsilon())

    f1 = 2*p*r / (p+r+K.epsilon())
    f1 = tf.where(tf.is_nan(f1), tf.zeros_like(f1), f1)
    return 1 - K.mean(f1)


def f1(y_true, y_pred):
    def recall(y_true, y_pred):
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
        recall = true_positives / (possible_positives + K.epsilon())
        return recall
    def precision(y_true, y_pred):
        true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
        predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
        precision = true_positives / (predicted_positives + K.epsilon())
        return precision
    precision = precision(y_true, y_pred)
    recall = recall(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))



def predict(vectorlist,model):

  if (len(vectorlist) > 0):
    one = []
    one.append(vectorlist)
    one = numpy.array(one)
    max_length = 200
    one = sequence.pad_sequences(one, maxlen=max_length)
    yhat_probs = model.predict(one, verbose=0)
    prediction = int(yhat_probs[0][0] * 100000)
    prediction = 0.00001 * prediction
    return prediction

  else:
    return -1



def getblocksVisual(mode, source_code, bad_positions, comment_areas, full_length, step, nr, w2v_model, model, threshold, name):
    word_vectors = w2v_model.wv
    ypos = xpos = 0
    lines = source_code.count("\n")
    img = Image.new('RGBA', (2000, 11 * (lines + 1)))
    color = "white"
    blocks = []
    focus = last_focus = 0
    string = ""
    trueP = falseP = False

    while focus <= len(source_code):
        comment = any(com[0] <= focus <= com[1] <= last_focus for com in comment_areas)
        focus_area = source_code[last_focus:focus]

        if focus_area != "\n":
            if comment:
                color = "grey"
                string += colored(focus_area, 'grey')
            else:
                middle = last_focus + round(0.5 * (focus - last_focus))
                context = getcontextPos(source_code, middle, full_length)

                if context is not None:
                    vulnerablePos = any(context[0] > bad[0] <= context[0] or context[1] > bad[0] <= context[1] or context[0] <= bad[0] <= context[1] for bad in bad_positions)
                    predictionWasMade = False
                    text = source_code[context[0]:context[1]].replace("\n", " ")
                    token = getTokens(text)

                    if len(token) > 1:
                        vector_list = [w2v_model.wv[t].tolist() for t in token if t in word_vectors.key_to_index and t != " "]

                        if vector_list:
                            p = predict(vector_list, model)
                            if p >= 0:
                                predictionWasMade = True

                            if vulnerablePos:
                                color = "royalblue" if p > 0.5 else "violet"
                                string += colored(focus_area, 'cyan' if p > 0.5 else 'magenta')
                            else:
                                color = next((col for col, thres in zip(["darkred", "red", "darkorange", "orange", "gold", "yellow", "GreenYellow", "LimeGreen", "Green", "DarkGreen"], threshold) if p > thres), "DarkGreen")
                                string += colored(focus_area, 'red' if p > 0.8 else 'yellow' if p > 0.5 else 'green')

                    if not predictionWasMade:
                        string += focus_area

        try:
            if focus_area:
                d = ImageDraw.Draw(img)
                if focus_area[0] == "\n":
                    ypos += 11
                    xpos = 0
                    d.text((xpos, ypos), focus_area[1:], fill=color)
                else:
                    d.text((xpos, ypos), focus_area, fill=color)
                xpos += d.textsize(focus_area)[0]
        except Exception as e:
            print(e)

        if "\n" in source_code[focus + 1:focus + 7]:
            last_focus = focus
            focus += source_code[focus + 1:focus + 7].find("\n") + 1
        else:
            next_split = nextsplit(source_code, focus + step)
            if next_split > -1:
                last_focus = focus
                focus = next_split
            else:
                if focus < len(source_code):
                    last_focus = focus
                    focus = len(source_code)
                else:
                    break

    display(img)
    file_path = f'/content/demo_{mode}_{name}.png'
    img.save(file_path)
    print("saved png.")
    return file_path
